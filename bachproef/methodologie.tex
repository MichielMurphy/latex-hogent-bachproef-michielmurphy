%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}%
\label{ch:methodologie}

\section [Verduidelijkingsfase huidige situatie]{Verduidelijkingsfase huidige geb\-ruikersinterface}
%Bron: https://docs.idp-z3.be/en/latest/introduction.html
De huidige gebruikersinterface van de tool Interactive Consultant (IC), weergegeven in Figuur \ref{fig:gui}, stelt experts in staat hun kennis over een specifiek probleemgebied te digitaliseren. Op basis van deze ingevoerde kennis kunnen eindgebruikers zelfstandig en interactief oplossingen vinden voor hun problemen~\autocite{Carbonnelle2024}. Gebruikers kunnen zelf informatie invoeren, waarna de IC de gevolgen van hun invoer weergeeft~\autocite{DeVogelaere2025}. Voordat een nieuwe gebruikersinterface kan ontwikkeld worden, moet de huidige situatie worden geanalyseerd. Dit omvat het in kaart brengen van de gebruikte frameworks, het datamodel en de manier waarop gegevens tussen de front-end en de back-end worden uitgewisseld. In deze fase wordt zowel het technische als visuele aspect benaderd.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{gui.png}
    \caption[Huidige gebruikersinterface.]{\label{fig:gui}De online shop voor laptops in de Interactive Consultant~\autocite{KULeuven}.}
\end{figure}

\subsection{Frontend - GUI}
Voor dit onderzoek wordt er gekeken naar de grafische gebruikersinterface van een online shop voor laptops. De grafische user interface is uitgewerkt in Angular, een TypeScript-based open-source front-end framework dat ontwikkeld is door Google. Er wordt gebruik gemaakt van de PrimeNG UI-componentenbibliotheek. Deze library biedt een verzameling van herbruikbare componenten.

\subsubsection{Opbouw GUI}
\paragraph{Header}
De header bevat het KU Leuven-logo, een titel en een menubalk, en blijft behouden in de nieuwe UI (zie Figuur \ref{fig:header}).

\begin{figure}
  \centering
  \includegraphics[width=1\textwidth]{header.png}
  \caption[Header huidige en nieuwe UI.]{\label{fig:header}De header van de Interactive Consultant met alle componenten~\autocite{KULeuven}.}
\end{figure}

\paragraph{ScrollPanel}
De content van de pagina zit vervat in een ScrollPanel. Deze scrollcontainer is opgedeeld in rijachtige structuur voor elke categorie van properties (zie Figuur \ref{fig:scrollpanel}).

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{scrollpanel.png}
    \caption[ScrollPanel van huidige UI]{\label{fig:scrollpanel}De content van de ScrollPanel opgedeeld in rijen op basis van de categorie van een property. In bovenstaande afbeelding zijn properties uit categorieën \textit{Product} en \textit{Battery} te zien~\autocite{KULeuven}.}
\end{figure}

\paragraph{Dropdown, binaire keuzeselector en invoerveld}
De properties worden weergegeven als dropdowns, binaire keuzeselectoren of invoervelden, afhankelijk van het type keuze dat de gebruiker moet maken. Dropdowns worden gebruikt wanneer er meerdere opties beschikbaar zijn, terwijl binaire keuzeselectoren geschikt zijn voor beslissingen met slechts twee mogelijke waarden, zoals ja/nee of aan/uit. De invoervelden zijn van het type number, waarbij zowel gehele als decimale waarden kunnen worden ingevoerd. In figuur \ref{fig:componenten} worden de drie UI-componenten afgebeeld.

\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{componenten.png}
    \caption[Dropdown, binaire keuzeselector en invoerveld]{\label{fig:componenten}Voor property \textit{weight} wordt  een numeriek invoerveld gebruikt, terwijl voor property \textit{fingerprint reader} een binaire keuzeselector wordt toegepast. De property \textit{optical drive type} wordt voorgesteld met een dropdown~\autocite{KULeuven}.}
\end{figure}

\subsection{Backend - Technisch}
\subsubsection{IDP-Z3}
IDP-Z3 is een redeneersysteem dat het Knowledge Base-paradigma implementeert met behulp van de FO[·]-taal. FO[·], ook bekend als FO-dot, is Eerste-Orde Logica waarmee kennis over een specifiek probleemgebied wordt vastgelegd. Deze kennis wordt vervolgens gebruikt om die problemen op te lossen door middel van redeneringen~\autocite{Carbonnelle2024}. In codefragment \ref{code:FO-language}  staat een voorbeeld van de FO[.]-taal dat  gebruikt wordt in deze studie als vereenvoudigde demo tijdens het maken van de proof-of-concept. Meer informatie over IDP-Z3 en de werking ervan is terug te vinden in de documentatie van~\textcite{Carbonnelle2024}.

\begin{listing}
\begin{minted}[
        frame=single,
        linenos,
        breaklines=true,
        fontsize=\small,
        baselinestretch=0.8
        ]{text}
        vocabulary V{
            type Product_code
            type Product_type
            type Brand
            type Family
            type Processor_model
            type Processor_family
            
            product_type: Product_code -> Product_type
            brand: Product_code -> Brand
            family: Product_code -> Family
            processor_model: Product_code -> Processor_model
            internal_memory: Product_code -> Int
            ssd_capacity: Product_code -> Int
            
            processor_family: Processor_model -> Processor_family
            processor_cores: Processor_model -> Int
            
            product_code_: -> Product_code
            product_type_: -> Product_type
            brand_: -> Brand
            internal_memory_: -> Int
            family_: -> Family
            processor_model_: -> Processor_model
            ssd_capacity_: -> Int
            processor_family_: -> Processor_family
            processor_cores_: -> Int
        }
        
        structure S: V{
            Product_code := {_9570_0286, *7790*5859, *5587*3835, *20RH0000US, *20QN003TUS, XXN03, *3579*7181, A15_9597, *3779*9822, PS585E_01F008DU, *9560*4575, *7373*0842, *9570*0378, PSC0ME_01S00TEN, _4UM36EA,…}
            Product_type := {Hybrid, Notebook, Mobile_workstation}.
            Brand := {DELL, Alienware, Toshiba, Lenovo, HP, Fujitsu}.
            Family := {LIFEBOOK, Satellite_Pro, *, G3, ENVY, ThinkBook, Latitude, Vostro, Tecra, Inspiron, FAMILY*MISSING, Portege, dynabook, ThinkPad, Precision, XPS, OMEN, G7, G5}.
            Processor_model := {i5_8250U, i5_8300H, E_2276M, i9_9880H, i5_8265U, i7_7Y75, i7_10510U, i5_7200U, i5_10210U, i7_8705G, i7_8565U, i7_6500U, i3_6006U, i7_7700HQ, i5_8400H, i5_8305G, i7_8850H, i5_6300U, i5_5200U, i9_8950HK, i7_9750H, i5_6200U, i7_6700HQ, i7_7500U, i7_8750H, T6670, i7_7600U, i7_9850H, i7_8665U, i7_1065G7, i7_8550U, i5_4210M}.
            product_type := {A15_9597 -> Notebook, A17_0289 -> Notebook, *3579*9785 -> Notebook, *3579*7181 -> Notebook, *0G4RK -> Notebook, *73M2V -> Notebook, T6FN6 -> Notebook, *3779*9488 -> Notebook, *3779*9822 -> Notebook, *5587*3835 -> Notebook, *5587*3719 -> Notebook, *5590*6061 -> Notebook, *5590*6078 -> Notebook, *7790*5842 -> Notebook, *7790*5859 -> Notebook}
        }
        
        theory T: V{
            ssd_capacity(product_code_()) = ssd_capacity_().
            product_type(product_code_()) = product_type_().
            family(product_code_()) = family_().
            processor_model(product_code_()) = processor_model_().
            brand(product_code_()) = brand_().
            internal_memory(product_code_()) = internal_memory_().
            processor_family(processor_model_()) = processor_family_().
            processor_cores(processor_model_()) = processor_cores_().
        }
        
        procedure main() {
            pretty_print(model_expand(S, T))
        }
    \end{minted}
    \caption{Vereenvoudigde laptop demo FO[·]-taal} \textbf{Vocabulary:} definieert alle woorden/types en relaties die gebruikt worden. \textbf{Structure:} de concrete data/waarden. \textbf{Theory:} de regels die worden gecontroleerd of afgeleid}
\label{code:FO-language}
\end{listing}

\subsubsection{Properties}
De properties worden ingeladen met een JSON-bericht. Wanneer een gebruiker een wijziging aanbrengt in een veld, wordt het systeem opnieuw berekend en wo\-rdt er een nieuw JSON-bestand naar de IC gestuurd. De IC communiceert continu met IDP-Z3 om tot een oplossing te komen.

\subsubsection{Datamodel}
Er is geen persistente opslag van de ingevoerde gegevens, wat betekent dat deze niet bewaard blijven tussen sessies of voor toekomstige gebruik. Omdat de backend alles opnieuw berekent, is er geen sprake van een klassiek datamodel waarin gegevens kunnen worden opgeslagen en later opgehaald. Dit maakt het systeem flexibel en zorgt ervoor dat het altijd met de meest actuele gegevens werkt, maar betekent ook dat er geen historisch overzicht of hergebruik van gegevens mogelijk is. Dit laatste aspect is van cruciaal belang voor de nieuwe gebruikersinterface.

\section{Requirements-analysefase}
Bij het ontwikkelen van een nieuwe gebruikersinterface is het belangrijk te weten waaraan deze moet voldoen. Hiervoor worden zowel de functionele als niet-functionele vereisten geformuleerd. Daarnaast worden ze geordend volgens prioriteit, gebruik makend van de MoSCoW-methode. Deze fase kan beschouwd worden als de start van de vergelijken\-de studie van beschikbare technologieën en bibliotheken.

\subsection{Functionele vereisten}
Deze vereisten beschrijven de functionaliteit die het systeem moet bieden, oftewel de functies die de interface moet ondersteunen om de gebruiker te helpen.

\subsubsection{Must have}
\paragraph{Selecteren van properties}
Een gebruiker moet op properties kunnen klikken om een waarde in te vullen voor de gekozen property of om de verklaring te krijgen waarom een waarde al is gekozen of ingevuld.

\paragraph{Geselecteerde properties bijhouden}
De geselecteerde properties moeten worden bijgehouden en apart weergegeven.

\paragraph{Deselecteren van properties}
Een gebruiker moet eerder gemaakte keuzes, zowel door zichzelf als door het systeem, ongedaan kunnen maken door een property te deselecteren. De waarde van de property moet worden gereset, zodat de betreffende property niet meer wordt bijgehouden of greyed out is.

\paragraph{Resetten van properties}
Een gebruiker moet de waarden van alle properties kunnen resetten.

\paragraph{Real-time feedback}
De interface moet de gevolgen van de selecties van een gebruiker weergeven en moet kunnen verduidelijken waarom bepaalde keuzes automatisch worden toegepast. Een gebruiker moet dus directe feedback krijgen voor elke keuze die hij maakt.

\paragraph{Opslaan klikgedrag en visuele indicaties}
Het systeem moet bijhouden welke properties door gebruikers worden aangeklikt, samen met de bijhorende relevantie. Wanneer een gebruiker een keuze ongedaan maakt door een property te deselecteren, moet het systeem de relevantie van die property opnieuw aanpassen. Op basis van deze relevantie bepaalt het systeem een gewicht of grootte voor elke property. Properties die frequent worden aangeklikt, worden groter en opvallender weergegeven. Het systeem werkt de weergave van de properties dagelijks bij.

\paragraph{Begeleiding}
De opgeslagen informatie van de properties wordt gebruikt om gerichte aanbevelingen te doen aan gebruikers. De interface moet vrijblijvende hulp en begeleiding bieden zonder de vrijheid van de gebruiker te beperken. Dit is belangrijk, aangezien de huidige interface geen ondersteuning biedt.

\paragraph{Visuele hiërarchie en uitlijning}
De interface moet een duidelijke visuele hiërarchie en uitlijning hebben, met een logische en compacte structuur voor de presentatie van gegevens, zodat de gebruiker niet wordt overrompeld door te veel informatie. Dit is essentieel, omdat dit momenteel het probleem is van de bestaande gebruikersinterface.

\paragraph{Eenvoudige navigatie}
De interface moet een eenvoudig navigatiepad bieden, zodat een gebruiker snel de gewenste informatie kan vinden en te allen tijde weet waar hij zich binnen de interface bevindt.

\paragraph{Backend integratie met IDP-Z3}
Het systeem moet in staat zijn om te communiceren met IDP-Z3, wat momenteel gebeurt op basis van JSON-berichten. Deze werkwijze moet behouden blijven.

\subsubsection{Should have}
\paragraph{Hoveren over properties}
Een gebruiker moet over properties kunnen hoveren om meer uitleg te krijgen over wat de betreffende property inhoudt.

\subsection{Niet-functionele vereisten}
Deze vereisten beschrijven hoe het systeem de functionele vereisten moet uitvoeren. 

\subsubsection{Must have}
\paragraph{Gebruiksvriendelijkheid}
De interface moet gebruiksvriendelijk zijn, zonder onnodige complexiteit en intuïtief aanvoelen, zodat een gebruiker er vlot mee kan werken.

\paragraph{Esthetiek en visueel design}
De interface moet een aantrekkelijke visuele laag bieden die de gebruiker niet alleen ondersteunt, maar ook een aangename ervaring biedt. Het design moet consistent, responsive en modern zijn.

\paragraph{Gebruik van kleuren}
De interface gebruikt kleuren om aan te geven welke properties relevant zijn en welke niet.

\subsubsection{Should have}
\paragraph{Prestaties}
De interface moet snel reageren op gebruikersinvoer en zonder merkbare vertraging worden bijgewerkt.

\section {Long list fase}
Dit onderzoek bouwt voort op een reeds bestaand en actief project. De huidige webclient is ontwikkeld met Angular, een JavaScript-gebaseerd framework. In deze fase wordt er onderzocht welke softwarebibliotheken, binnen JavaScript of Angular zelf, geschikt zijn voor dit onderzoek. De focus ligt op libraries die gunstig zijn voor data- of tekstvisualisatie, aangezien het met de nieuwe webclient mogelijk moet zijn om woorden op een elegante en compacte manier weer te geven in verschillenden kleuren en groottes.\smallskip\par
Binnen een library zijn vaak meerdere visualisatiemethoden beschikbaar. De insteek van deze bachelorproef was initieel om te onderzoeken of het mogelijk is een woordwolk te implementeren als nieuwe gebruikersinterface. Deze vergelijkende studie gaat echter breder dan alleen libraries voor woordwolken. Uit onderzoeken van~\textcite{Wang2015} worden er volgende categorieën van datavisualisatietechnieken aangehaald: grafieken, netwerken en hiërarchieën.\par Vooraleer een keuze wordt gemaakt, wordt de literatuur doorzocht naar alternatieven binnen deze drie categorieën.

\subsection{Gevonden alternatieven}
\subsubsection{D3.js}
D3.js is een open-sourcebibliotheek die zich richt op animaties, interacties en dynamische visualisaties. De nadruk ligt op de efficiënte manipulatie van HTML-eleme\-ten. Standaard genereert D3.js geen voorgedefinieerde visualisaties; de functionaliteit moet daarom worden uitgebreid met plug-ins of externe bibliotheken. De bibliotheek biedt een breed scala aan lay-outs voor verschillende soorten data~\autocite{Wang2015}.
\subsubsection{Sigma.js}
Sigma.js is een open-sourcebibliotheek die in staat is dynamische interactieve grafen te tekenen. Deze library is makkelijk inzetbaar en kan vlot worden geïntegreerd in bestaande webtoepassingen. De standaardinstellingen van de bibliotheek bevatten diverse ingebouwde functies, waaronder ondersteuning voor muis- en aanraakbediening~\autocite{Wang2015}.
\subsubsection{Cytoscape.js}
Cytoscape.js is een open-sourcebibliotheek ontworpen voor het visualiseren van grafen. Het ondersteunt verschillende gebruikersinteracties zoals selecteren en pannen~\autocite{Wang2015}.
\subsubsection{Highcharts}
Highcharts is een open-sourcebibliotheek die ondersteuning biedt voor interactieve grafieken op basis van CSV- en JSON-data~\autocite{Vucetic2023}. De library beschikt over een eigen chatbot, wat het vergemakkelijkt om snel informatie op te zoeken en problemen op te lossen~\autocite{Highcharts2025}.
\subsubsection{amCharts}
amCharts is een hulpmiddel voor het visualiseren van complexe data via interactieve grafieken en kaarten. Standaard wordt data geleverd via een array die in de JavaScript-code is opgenomen, maar voor geavanceerdere toepassingen kunnen ook andere databronnen worden gebruikt~\autocite{Chandra2022}.
\subsubsection{Vega}
Vega functioneert als een raamwerk voor datavisualisatie. Het visuele uiterlijk en het interactieve gedrag wordt gedefinieerd aan de hand van JSON~\autocite{Chandra2022}. 
\subsubsection{ZingChart}
ZingChart biedt ontwikkelaars een oplossing voor het creëren van responsieve visualisaties~\autocite{Chandra2022}.
\medskip\par
Naast het raadplegen van wetenschappelijke en professionele bronnen, wordt er ook gezocht naar open-source GitHub-bibliotheken voor woordwolkvisualisaties. Hierbij is volgende alternatief gevonden:
\begin{itemize}
    \item \textbf{Wordcloud2.js}: een standalone library van Timothy Guan-tin Chien~\autocite{Chien2011}.
\end{itemize}

\subsection{Toetsen requirements}
In dit deel van de fase worden de officiële websites en documentatie van elk alternatief zijn grondig bestudeerd. Vooraleer de vereisten geëvalueerd en getoetst kunnen worden, is het essentieel om eerst te bepalen welke visualisaties het meest geschikt en relevant zijn voor dit onderzoek. De nieuwe interface moet gestructureerd, overzichtelijk, compact, intuïtief én visueel aantrekkelijk zijn. Bepaalde visualisatietypes zoals lijn-, staaf- en kolomgrafieken, worden uitgesloten. Na een grondige analyse van de mogelijke visualisaties binnen de bibliotheken uit de long list, blijken de volgende structuren geschikt voor dit onderzoek: een woordwolk, een (packed) bubble chart en een graaf.\medskip\par
Om de requirements op een correcte manier te kunnen toetsen, moet eerst technisch worden nagedacht over hoe elke vereiste geïmplementeerd kan worden. Da\-arbij wordt binnen de softwarebibliotheken gezocht naar functionaliteiten die standaard door de library worden aangeboden. Dit zijn de gewenste eigenschappen:
\begin{itemize}
    \item \textbf{Klik functie}: de gebruiker moet op een woord kunnen klikken om er een waarde aan toe te kennen.
    \item \textbf{State management}: de gebruiker moet een overzicht kunnen zien van de woorden waaraan hij al een waarde heeft toegekend.
    \item \textbf{(Re)render functie}: de visualisatie moet zich kunnen aanpassen of opnieuw laden op basis van de interacties van de gebruiker.
    \item \textbf{Gebruik van verschillende kleuren binnen de visualisatie}: kleuren bieden visuele begeleiding, geven betekenis en zorgen voor een aangename uitstraling.
    \item \textbf{Gebruik van verschillende tekstgroottes binnen de visualisatie}: variatie in tekstgrootte ondersteunt visuele hiërarchie, structuur en leesbaarheid.
    \item \textbf{Hover functie}: de gebruiker moet met de muis over een woord kunnen bewegen om extra informatie over dat woord te verkrijgen.
\end{itemize}

De vereisten in de tabellen zijn gerangschikt volgens de volgorde zoals gedefinieerd in de requirementsanalysefase. Deze structuur wordt in de tabel weergegeven met een horizontale oriëntatie, waarbij de vereisten van links naar rechts worden gepresenteerd.

\paragraph{D3.js - Woordwolk}
Uit de documentatie van~\textcite{D3Contributors2025} en~\textcite{Mike2025} blijkt dat D3.js, en dus ook de woordwolkcomponent, ingebouwde klik- en hoverfunctionaliteiten biedt. Dit houdt in dat zowel het selecteren en deselecteren van eigenschappen als het tonen van extra informatie bij een woord wordt ondersteund. Het opslaan van klikgedrag is mogelijk, waardoor een relevantieverschil tussen eigenschappen kan worden opgebouwd. Ook het instellen van verschillende kleuren en tekstgroottes per woord is ondersteund. Bovendien kan D3.js goed overweg met JSON-data. Deze visualisatie maakt het dus mogelijk om visuele indicaties, begeleiding en hiërarchie te implementeren. Hoewel het bijhouden van geselecteerde properties niet standaard wordt voorzien binnen D3.js, kan deze functionaliteit wel eenvoudig worden toegevoegd via state management binnen het gebruikte JavaScript-framework.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{D3.js Woordwolk - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & $\bullet$ & $\bullet$ & ? \\
            \bottomrule
        \end{tabular}
        \caption{D3.js Woordwolk - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}

\paragraph{D3.js - Bubble Chart}
Uit de documentatie van~\textcite{D3Contributors2025} en~\textcite{Mike2025a} blijkt dat de bubble chart-visualisatie sterk gelijkt op de woordwolk. Er is echter een duidelijk visueel verschil tussen beide libraries. Woordwolken gebruiken tekst als primair visueel element, met variaties in grootte, kleur en oriëntatie. Bubble charts daarentegen maken gebruik van cirkels als primair visueel element, waarbij tekst meestal een secundaire rol speelt. Het bijhouden van geselecteerde eigenschappen is ook in dit geval niet standaard voorzien binnen D3.js, maar deze functionaliteit kan worden toegevoegd via state management binnen het gebruikte JavaScript-framework.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{D3.js Bubble Chart - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & $\bullet$ & $\bullet$ & ? \\
            \bottomrule
        \end{tabular}
        \caption{D3.js Bubble Chart - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}

Wanneer er met grote datasets wordt gewerkt, kan een bubble chart onoverzichtelijk worden omdat deze niet meer binnen de schermgrootte past of niet volledig in één scherm weergegeven kan worden. Bubbels die zeer relevante woorden bevatten, kunnen namelijk snel te groot worden, terwijl tekst alleen minder ruimte inneemt.

\paragraph{Sigma.js - Graaf}
Uit de documentatie van~\textcite{SigmaJS2025} blijkt dat alle functionele requirements haalbaar zijn, met uitzondering van het bijhouden van de geselecteerde properties. Er zijn voldoende ondersteunde events beschikbaar, zoals klik-, enter- en leaveNode-events. Sigma.js zorgt ervoor dat de volledige graaf zichtbaar is en benut de beschikbare ruimte efficiënt. Een interessante functionaliteit van Sigma.js in het kader van dit onderzoek is de mogelijkheid om vlak vóór het renderen de eigenschappen van nodes dynamisch aan te passen.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Sigma.js - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & ? \\
            \bottomrule
        \end{tabular}
        \caption{Sigma.js - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}

\paragraph{Cytoscape.js - Graaf}
Het artikel van~\textcite{Franz2015} en de documentatie van Cytoscape.js~\textcite{Franz2025} geven aan dat de functionaliteiten van de library aan de meeste requirements voldoen. Opnieuw is er geen ingebouwde mogelijkheid om de geselecteerde properties bij te houden. Cytoscape.js maakt real-time feedback mogelijk dankzij de functionaliteit om elementen dynamisch toe te voegen, te verwijderen of te wijzigen. Daarnaast kunnen stylesheets tijdens runtime worden vervangen om de visuele stijl aan te passen. Deze library biedt ondersteuning voor JSON-import en -export, wat de integratie met backend-systemen zoals het IDP-Z3-syst\-eem mogelijk maakt. Ook gebruikersinteracties zoals klikken en hoveren kunnen worden afgehandeld. Een nuttige functionaliteit in het kader van dit onderzoek is dat de visualisatie automatisch wordt gerenderd wanneer nodig.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Cytoscape.js - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Cytoscape.js - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}

\paragraph{Highcharts - Woordwolk}
Volgens de website en documentatie van~\textcite{Highcharts2009,Highcharts2009a} biedt de module zowel ingebouwde klik- als hoverfunctionaliteit, waardoor gebruikersinteracties kunnen worden afgehandeld. Daarnaast is het mogelijk om tekstgroottes en kleuren per woord aan te passen, wat belangrijk is voor het visualiseren van prioriteit en categorieën. Highcharts heeft een functie \textit{redraw} waardoor de woordwolk opnieuw wordt gerenderd. Highcharts kan overweg met JSON-data, maar heeft geen ingebouwde mogelijkheid voor het bijhouden van geselecteerde properties. Dit kan worden opgelost binnen de Angular-omgeving.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Highcharts Woordwolk - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & ? \\
            \bottomrule
        \end{tabular}
        \caption{Highcharts Woordwolk - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}

\paragraph{Highcharts - Packed Bubble Chart}
Net als bij de woordwolk ondersteunt de packed bubble chart klik- en hoverfuncties, en kunnen zowel kleuren als groottes aangepast worden op basis van de data. Beide visualisaties binnen Highcharts vertonen sterke gelijkenissen qua functionaliteit, maar verschillen in visuele presentatie. In tegenstelling tot de woordwolk maakt de packed bubble chart gebruik van cirkels, waarbij de grootte van elke cirkel wordt bepaald door de relevantie van de property~\autocite{Highcharts2009,Highcharts2009a}.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Highcharts Packed Bubble Chart - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & ? \\
            \bottomrule
        \end{tabular}
        \caption{Highcharts Packed Bubble Chart - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}
\paragraph{amCharts - Woordwolk}
Uit de documentatie van~\textcite{amCharts2025} blijkt dat de woordwolkcomponent zeer flexibel is en tal van interactieve mogelijkheden biedt. Zo ondersteunt de bibliotheek zowel klik- als hoverfunctionaliteiten en laat ze toe om eigenschappen zoals grootte, kleur en positie van woorden dynamisch aan te passen. Daarnaast beschikt amCharts over geavanceerde animatieopties, wat zorgt voor een aantrekkelijke en gebruiksvriendelijke interface. De duidelijke ondersteuning voor JSON-data maakt het bovendien eenvoudig om te koppelen met de backend. De library biedt opnieuw geen ingebouwde state management voor het bijhouden van geselecteerde properties. Volgens~\textcite{Ravishankkar2017} heeft amCharts ook geen prestatieproblemen.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{amCharts Woordwolk - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{amCharts Woordwolk - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}
\paragraph{Vega - Woordwolk}
De bibliotheek werkt met JSON-specificaties die de visualisatie en interacties definiëren. Uit de documentatie blijkt dat Vega ondersteuning biedt voor gebruikersinteracties zoals klikken en hoveren, en dat de visualisatie kan worden aangepast op basis van dynamische data. Hoewel Vega zeer flexibel is, vereist het meer code en configuratie dan gespecialiseerde woordwolk-libraries. Het bijhouden van geselecteerde properties is niet ingebouwd en moet worden geïmplementeerd in de Angular-applicatie. Volgens het onderzoek van~\textcite{Satyanarayan2017} is de interactieve performance van Vega minstens twee keer zo snel als die van een gelijkwaardig D3-programma.
\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Vega Woordwolk - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Vega Woordwolk - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}
\paragraph{Vega - Packed Bubble Chart}
De packed bubble chart visualisatie in Vega ondersteunt dezelfde functionaliteiten als de woordwolk. Ze verschillen enkel in visuele weergave.

\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Vega Packed Bubble Chart - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Vega Packed Bubble Chart - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}
\paragraph{ZingChart - Woordwolk}
ZingChart bevat een renderfunctie waarmee verschillende renderopties kunnen worden meegegeven. Zowel klik- als hoverfunctionaliteit is mogelijk. Daarnaast geeft de documentatie aan dat de grootte, kleur en positie van woorden aangepast kunnen worden. Integratie met het backend-systeem is haalbaar, maar ingebouwd state management ontbreekt~\autocite{ZingChart2009}.
\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{ZingChart Woordwolk - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            ? & $\bullet$ & $\bullet$ & ? \\
            \bottomrule
        \end{tabular}
        \caption{ZingChart Woordwolk - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}

\paragraph{Wordcloud2.js - Woordwolk}
Uit de API-documentatie van~\textcite{Chien2011a} blijkt duidelijk welke functionaliteiten beschikbaar zijn binnen de woordwolk. De documentatie biedt een overzicht van de opties die kunnen worden meegegeven bij de configuratie. De woordwolk beschikt over ingebouwde klik- en hoverfuncties, en het is mogelijk om per woord een specifieke kleur en tekstgrootte toe te kennen. De library is eenvoudig te integreren en vereist minimale configuratie voor basisfunctionaliteit. WordCloud2.js werkt met arrays van woorden en gewichten, wat compatibel is met de JSON-data die het backend-systeem aanlevert. Net als bij de andere libraries is er echter geen ondersteuning voor het bijhouden van geselecteerde properties.
\begin{table}[htbp]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccccccccc|c|}
            \hline
            \multicolumn{9}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & --- & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Wordcloud2.js Woordwolk - Functionele requirements}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \begin{tabular}{|ccc|c|}
            \hline
            \multicolumn{3}{|c|}{M} & \multicolumn{1}{c|}{S} \\
            \midrule
            $\bullet$ & $\bullet$ & $\bullet$ & $\bullet$ \\
            \bottomrule
        \end{tabular}
        \caption{Wordcloud2.js Woordwolk - Niet-functionele requirements}
    \end{minipage}
    \caption*{($\bullet$ = req aanwezig; --- = req niet aanwezig; ? = geen info beschikbaar)}
\end{table}
\medskip\par Voor dit onderzoek mag geen enkele library prestatieproblemen vertonen, aangezien het prototype geen grote dataset hoeft te verwerken.

\section {Short list fase}
Uit de longlistfase kan geconcludeerd worden dat de besproken alternatieven sterk op elkaar lijken en grotendeels vergelijkbare functionaliteiten bieden. Het meest opvallende patroon is dat geen van de bibliotheken native ondersteuning biedt voor het bijhouden van geselecteerde properties. In dit onderzoek wordt er verdergegaan met de lichtgewicht, standalone library Wordcloud2.js. Een van de doelstellingen van deze studie is te onderzoeken of het mogelijk is om een woordwolk te integreren in de huidige webinterface. Aangezien deze library eenvoudig te integreren is en beschikt over duidelijke documentatie, vormt ze een geschikt alternatief.

\section{Architectuur van de nieuwe gebruikersinterface}
Een softwarebibliotheek is niet voldoende om een nieuwe gebruikersinterface te bouwen. De architectuur van de nieuwe gebruikersinterface moet ook besproken worden.

\subsection{Frontend}
Zoals hierboven reeds gezegd, is de frontend van de huidige webinterface ontwikkeld in Angular en blijft dit ongewijzigd. De gekozen softwarebibliotheek Wordcloud2.js wordt geïmplementeerd en gebruikt om een woordwolk te visualiseren.

\subsection{Backend IDP-Z3}
Het hele achterliggende redeneersysteem blijft ook behouden en ongewijzigd aangezien dit los staat van de nieuwe webinterface.

\subsection{Backend Node.js en Express}
Om het klikgedrag van de gebruiker op te slaan, is een REST API nodig. Wanneer de gebruiker een waarde toekent aan een property, wordt een HTTP-request verstuurd naar deze REST API om de interactie te registreren. Hiervoor wordt een backend opgezet met Node.js en Express in TypeScript, gebaseerd op een structuur die vergelijkbaar is met de tutorial van~\textcite{Mallawaarachchi2023}.

\subsection{PostgreSQL en PgAdmin}
De REST API heeft een databank nodig om de properties en interacties op te slaan. Er is gekozen voor de relationele databank PostgreSQL. Voor het beheren van deze databank wordt de grafische tool PgAdmin gebruikt.

\paragraph{Opmerking}
De keuze voor tools en frameworks zoals Express, Node.js en PostgreSQL is niet doorslaggevend voor dit onderzoek. Ze dienen enkel als hulpmiddelen om tot een oplossing te komen; hetzelfde resultaat kan ook met andere tools en frameworks worden bereikt.

\section{Proof-of-concept bouwen}
\subsection{Inlezen op huidige code}
Zoals vermeld in de verduidelijkingsfase bouwt dit onderzoek voort op een bestaand en actief project. De oorspronkelijke, volledige codebase is terug te vinden in de GitLab-repository van~\textcite{Carbonnelle2019}. Vooraleer er aanpassingen of uitbreidingen aan de code kunnen worden gedaan, is het belangrijk om eerst de relevante bestaande code te bestuderen en te begrijpen. Voor dit onderzoek wordt specifiek gekeken naar het deelproject idp\_web\_client, aangezien dit de code bevat voor de visualisatie en verwerking van de Interactive Consultant.

\subsection{Woordwolk visualisatie}
Eerst en vooral moet de library worden geïntegreerd in het project.
\begin{verbatim}npm install github:timdream/wordcloud2.js --save\end{verbatim}
Om de woordwolk effectief te kunnen gebruiken en aanroepen, moet deze worden geïmporteerd in het gewenste bestand.
\begin{verbatim}import WordCloud from 'wordcloud';\end{verbatim}
Het principe van een woordwolk is dat deze bestaat uit woorden, waarbij elk woord een bepaald gewicht en een kleur heeft. In deze studie kan het gewicht van een woord geassocieerd worden met de relevantie ervan. Zoals te zien is in de API-documentatie van de library~\autocite{Chien2011}, kunnen verschillende opties worden meegegeven aan de woordwolk. Een daarvan is \textit{list}: een tweedimensionale array waarin elk woord samen met de bijbehorende relevantie wordt opgegeven.

\paragraph{Woorden}
In de huidige webinterface wordt geen gebruikgemaakt van een datamodel. De backend verstuurt alle benodigde informatie naar de webclient via een JSON-beri\-cht, dat in de webclient wordt bijgehouden in een meta-object. De properties worden hieruit gehaald en op het scherm weergegeven. Wanneer de gebruiker een waarde invult voor een property, herberekent de backend alle properties en wordt een nieuw JSON-bericht verstuurd, genaamd eval, waarna het meta-object wordt geüpdatet. Voor dit onderzoek zijn zowel de inhoud als de structuur van deze JSON-berichten van belang.

\begin{figure}
    \centering
    \begin{minipage}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{structuurJson.png}
        \caption[JSON-bericht]{\label{fig:structuurJson}Opbouw van meta en eval}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.48\textwidth}
        \centering
        \includegraphics[width=\textwidth]{structuurSymbol.png}
        \caption[Symbool]{\label{fig:structuurSymbol}Structuur van symbool}
    \end{minipage}
\end{figure}

De JSON-berichten, meta en eval, hebben dezelfde structuur maar verschillen in inhoud. In deze studie wordt enkel gewerkt met de volgende twee elementen: \textit{symbols} en \textit{valueInfo}. De array \textit{symbols} bevat symbolen die elk een element \textit{idpname} bevatten. Deze woorden worden gebruikt om in de woordwolk weer te geven. In het eerste deel van deze fase krijgen de woorden een vaste, hardgecodeerde relevantie. Later worden de gewichten uit de databank opgehaald. Het element \textit{valueInfo} bevat informatie over de mogelijke en de actuele waarde van elk symbool.
\medskip
\par Wanneer er op een woord wordt geklikt, verschijnt er een pop-upvenster met daarin een van de eerder genoemde invoerelementen. Zoals geïllustreerd in figuur  \ref{fig:app-symbol}, wordt gebruikgemaakt van het reeds bestaande \textit{app-symbol}-component.
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{app-symbol.png}
    \caption[App-symbol component]{\label{fig:app-symbol}De manier waarop een waarde wordt ingevuld, is dezelfde als in de huidige interface.}
\end{figure}

\subsection{Integratie REST API en databank}
Om de gebruiker te helpen vinden wat hij zoekt, is het noodzakelijk om onderscheid te kunnen maken in de relevantie van woorden. Dit benadrukt de noodzaak van een REST API en een databank, aangezien dit met het huidige datamodel niet eenvoudig kan worden bijgehouden. Hiervoor worden twee tabellen aangemaakt: \textit{properties} en \textit{user\_interactions} (zie codefragment \ref{code:postgresql-tabellen}).
\begin{listing}
    \begin{minted}[
        frame=single,
        linenos,
        breaklines=true,
        fontsize=\small,
        baselinestretch=0.8
        ]{postgresql}
        CREATE TABLE properties ( 
        id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
        guinaam VARCHAR(100) NOT NULL, 
        relevantie INTEGER NOT NULL 
        );
        
        CREATE TABLE user_interactions (
        id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
        propertyid INTEGER NOT NULL,
        timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        interaction_type INTEGER NOT NULL DEFAULT 0 
        CHECK (interaction_type IN (-2, 2)),
        FOREIGN KEY (propertyid) REFERENCES properties(id)
        );
    \end{minted}
    \caption{PostgreSQL-schema voor het creëren van de tabellen}
    \label{code:postgresql-tabellen}
\end{listing}
De REST API is een Node.js- en Express-server geschreven in TypeScript en draait op poort 3000. Er is bewust gekozen om de databank onafhankelijk op te zetten, zodat andere databankimplementaties eenvoudig kunnen worden toegevoegd zonder dat bestaande code aangepast hoeft te worden. In codefragment \ref{code:config/db} is te zien hoe de juiste databaseimplementatie wordt geselecteerd op basis van een omgevingsvariabele. De file \textit{postgres-db.ts} (zie codefragment \ref{code:config/postgres}) bevat de queries en databaselogica specifiek voor PostgreSQL. Deze implementeert de DatabaseInterface met concrete methoden voor het ophalen, aanmaken en bijwerken van gegevens in een PostgreSQL-database. Door deze implementatie te scheiden van de interface in \textit{database.ts} (zie codefragment \ref{code:types/database}), wordt het dus mogelijk om eenvoudig andere databasetypes toe te voegen zonder de rest van de applicatie aan te passen.
\begin{listing}
    \begin{minted}[
        frame=single,
        linenos,
        breaklines=true,
        fontsize=\small,
        baselinestretch=0.8
        ]{typescript}
        import { DatabaseInterface } from '../types/database';
        import postgresDb from './postgres-db';
        // Hier zou je andere database-implementaties kunnen importeren
        import dotenv from 'dotenv';
        
        dotenv.config();
        
        // Configureer welke database je wilt gebruiken op basis van omgevingsvariabele
        const dbType = process.env.DB_TYPE || 'postgres';
        
        let db: DatabaseInterface;
        
        switch (dbType) {
            case 'postgres':
            db = postgresDb;
            break;
            // Andere cases voor andere databases
            default:
            db = postgresDb; // Standaard als fallback
        }
        
        export default db;
    \end{minted}
    \caption{config/db.ts: bevat configuratie voor het type databank dat wordt gebruikt}
    \label{code:config/db}
\end{listing}

\begin{listing}
    \begin{minted}[
        frame=single,
        linenos,
        breaklines=true,
        fontsize=\small,
         baselinestretch=0.8
        ]{typescript}
        export interface DatabaseInterface {
            findByGuinaam(tableName: string, guinaam: string): Promise<any>;
            findByGuinaams(tableName: string, guinaams: string[]): Promise<any[]>;
            create(tableName: string, data: any): Promise<any>;
            findAll(tableName: string): Promise<any[]>;
            addUserInteractionSelectedPropertyToe(tableName: string, guinaam: string): Promise<any>;
            addUserInteractionUnselectedPropertyToe(tableName: string, guinaam: string): Promise<any>;
            increaseRelevanceProperty(tableName: string, guinaam: string): Promise<any>;
            decreaseRelevanceProperty(tableName: string, guinaam: string): Promise<any>;
        }
    \end{minted}
    \caption{types/database.ts: interface met de te implementeren methoden per type databank}
    \label{code:types/database}
\end{listing}

\begin{listing}
    \begin{minted}[
        frame=single,
        linenos,
        breaklines=true,
        fontsize=\small,
        baselinestretch=0.8
        ]{typescript}
        import { Pool, QueryResult } from 'pg';
        import { DatabaseInterface } from '../types/database';
        import dotenv from 'dotenv';
        import { PropertyModel } from '../types/property';
        
        dotenv.config();
        
        class PostgresDatabase implements DatabaseInterface {
            private pool: Pool;
            
            constructor() {
                this.pool = new Pool({
                    user: process.env.DB_USER,
                    host: process.env.DB_HOST,
                    database: process.env.DB_NAME,
                    port: parseInt(process.env.DB_PORT || '5432')
                });
            }
    \end{minted}
    \caption{config/postrgres-db.ts: een implementatie van de DatabaseInterface voor PostgreSQL. Het bevat de concrete logica voor het uitvoeren van database-operaties specifiek voor PostgreSQL. De concrete code is verschillend voor elk onderzoek.}
    \label{code:config/postgres}
\end{listing}

\paragraph{Synchroniseren woorden}
Wanneer de Interactive Consultant wordt ingeladen, wordt een HTTP-POST-request verstuurd naar http://localhost:3000/. In de frontend wordt de \textit{idpname} van de symbolen uit het meta-object gehaald, ontdaan van underscores en meegestuurd in het request naar de backend. Vervolgens worden de properties uit de databank opgehaald en vergeleken met de ontvangen symbolen. Symbolen die nog niet in de databank aanwezig zijn, maar wel in het request voorkomen, worden toegevoegd aan de tabel \textit{properties}. Het is belangrijk dat de symbolen uit het initiële meta JSON-bericht en die in de databank voortdurend gesynchroniseerd blijven

\paragraph{Ophalen gewichten van woorden}
Bij het toevoegen van een property aan de tabel \textit{properties} wordt de initiële relevantie van het bijbehorende woord op 15 gezet. Wanneer de renderfunctie van de woordwolk wordt aangeroepen, worden de properties met hun bijbehorende gewicht uit deze tabel opgehaald en toegewezen aan de array die wordt meegegeven aan de optie \textit{list} van de woordwolk.

\paragraph{Gebruikersinteractie registreren}
Om de voorkeuren van de gebruiker in kaart te brengen, moeten zijn of haar keuzes worden vastgelegd. Hiervoor wordt gekeken naar het element \textit{valueInfo} van de eval JSON-berichten. Zoals eerder vermeld, wordt het meta-object in de frontend telkens bijgewerkt wanneer er een nieuw JSON-bericht van de backend wordt ontvangen. Wanneer de gebruiker een waarde toekent aan een property, krijgt deze de status \textit{GIVEN}. Elke property start initieel met de status \textit{UNKNOWN}, en krijgt deze status ook terug wanneer de gebruiker de waarde reset. Om te achterhalen welke property werd gereset, wordt gekeken naar het element \textit{previousActive}, dat alle symbolen bevat met hun waarden en statussen. In de code worden zowel de \textit{GIVEN}-symbolen als de \textit{previousGIVEN}-symbolen bijgehouden in een array. Wanneer het meta-object verandert en het aantal \textit{GIVEN}-symbolen groter is dan dat van de \textit{previousGIVEN}-symbolen, kan worden geconcludeerd dat de gebruiker een waarde heeft toegekend aan een property. Vervolgens wordt gekeken welk symbool aanwezig is in de \textit{GIVEN}-array maar niet in de \textit{previousGIVEN}-array. Dit is de property waarvan de relevantie verhoogd moet worden. Hetzelfde principe geldt omgekeerd voor het verlagen van de relevantie wanneer een waarde wordt gereset. 

Om de gebruikersacties effectief te registreren wordt de tabel \textit{user\_interactions} gebruikt. Deze tabel registreert de volgende interacties:
\begin{itemize}
    \item \underline{Selecteren van een property}: het invullen van een waarde (relevantie +2)
    \item \underline{Deselecteren van een property}: het resetten van een waarde (relevantie -2)
\end{itemize}
Naast de \textit{propertyid} wordt ook het tijdstip van de interactie opgeslagen. Hierdoor kan de woordwolk periodiek worden bijgewerkt. Aan het einde van de dag worden alle interacties van die dag per property opgeteld en bij de bestaande relevantiewaarde in de tabel \textit{properties} gevoegd. Zo ontstaat er na verloop van tijd een beeld van welke properties het meest relevant zijn voor de gebruiker. Hoewel de periodieke updates niet volledig zijn uitgewerkt in deze studie, vormen ze een waardevolle uitbreiding van deze bachelorproef.

\paragraph{Relevantie rechtstreeks aanpassen}
De aanpak om de relevantie van properties te wijzigen, zoals hierboven beschreven, is niet geschikt voor een demo. Daarom wordt er best ook een demovriendelijke werkwijze uitgewerkt. In plaats van de gebruikersinteracties op te slaan in de tabel \textit{user\_interactions}, wordt de relevantie rechtstreeks aangepast in de tabel \textit{properties}. De logica om te bepalen welke property moet worden aangepast, blijft ongewijzigd. Het verschil zit in de uitvoering: er wordt eenvoudigweg een HTTP-POST-request verstuurd naar een ander endpoint.

\subsection{Styling van de woordwolk}
In dit onderzoek is de visuele uitstraling minstens even belangrijk als de implementatie van functionaliteit. Daarom wordt er gewerkt met kleuren en animaties. Volgende zaken worden verwerkt:
\begin{itemize}
    \item {Kleur van een property per categorie}
    \item {Uitleg over een property bij hoveren}
    \item {Kader rondom de property bij hoveren}
    \item {Achtergrondkleur van een \textit{consequency} property}
\end{itemize}
Om een overvloed aan kleuren te vermijden, krijgt elke property een kleur toegewezen op basis van de categorie. De unieke categorieën worden uit het meta-object gehaald en per sessie bijgehouden. Wanneer een gebruiker over een property hovert, verschijnt rechtsboven een tooltip met extra uitleg over de betreffende property (zie Figuur \ref{fig:tooltip}). Bij het hoveren wordt de property bovendien omkaderd in dezelfde kleur als die van de property zelf. Dit helpt de gebruiker om duidelijk te zien welke property hij mogelijk zal selecteren. \textit{CONSEQUENCE}-symbolen zijn properties waaraan de backend, het redeneersysteem, een waarde toekent als gevolg van een keuze van de gebruiker. Het invullen van een waarde bij een property kan dus gevolgen hebben voor de waarde van andere properties. Ook deze \textit{CONSEQUENCE}-symbolen worden uit het meta-object gehaald en bijgehouden in de webclient. Ze hebben de status \textit{CONSEQUENCE}. In de woordwolk worden deze symbolen weergegeven met een grijze achtergrondkleur (zie Figuur \ref{fig:consequence}).
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{tooltip.png}
    \caption[Styling bij het hoveren]{\label{fig:tooltip}De gehoverde property fingerprint reader wordt omrand in de bijbehorende kleur, en er verschijnt een tooltip met extra informatie over deze property.}
\end{figure}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{consequence.png}
    \caption[Consequence-symbmolen]{\label{fig:consequence}De consequence-symbolen krijgen een grijze achtergrondkleur toegewezen.}
\end{figure}
\medskip\par Kaders en achtergrondkleuren zijn niet eenvoudig te implementeren, aangezien de posities van de woorden van de woordwolk niet standaard worden opgeslagen. Om dit probleem te omzeilen, worden muishover-events gesimuleerd waarbij de posities van de gehoverde properties worden opgeslagen.

\paragraph{Visuele resultaat proof-of-concept}
In dit onderdeel wordt het visuele resultaat van de proof-of-concept weergegeven. In Figuur \ref{fig:startscenario} is het startscenario van de webinterface te zien. Wanneer de applicatie voor de eerste keer wordt opgestart, krijgt elke property standaard dezelfde relevantiewaarde, namelijk 15.
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{startscenario.png}
    \caption[Startscenario webinterface]{\label{fig:startscenario}In het startscenario is de relevantie van elke property 15, wat resulteert in een woordwolk waarin alle woorden even groot worden weergegeven.}
\end{figure}
Figuur \ref{fig:doelscenario} is het beoogde scenario van deze bachelorproef. Het toont een mogelijke weergave van de woordwolk na langdurig gebruik. De belangrijkste properties voor de gebruikers zijn degene met de hoogste relevantiewaarde. Dit scenario wordt in de code gesimuleerd met de functie kenGewichtToe (zie codefragment \ref{code:kenGewichtToe}). Deze functie kent willekeurig een gewicht toe aan een woord, op basis van drie vooraf gedefinieerde gewichtscategorieën. De bijhorende code dient enkel ter illustratie en wordt verder niet gebruikt binnen de applicatie.
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{doelscenario.png}
    \caption[Doelscenario webinterface]{\label{fig:doelscenario}In het doelscenario varieert de relevantie van de properties in functie van de interacties van de gebruiker.}
\end{figure}

\begin{listing}
    \begin{minted}[
        frame=single,
        linenos,
        breaklines=true,
        fontsize=\small,
        baselinestretch=0.8
        ]{typescript}
        kenGewichtToe(): number {
            const categorie1 = 15;
            const categorie2 = 28;
            const categorie3 = 60;
            
            const aantalWoorden = this.allSymbols.length;
            
            // Maximale aantallen per categorie
            const maxCategorie1 = Math.round(aantalWoorden * 0.50); // 50% van totaal
            const maxCategorie2 = Math.round(aantalWoorden * 0.35); // 35% van totaal
            const maxCategorie3 = Math.round(aantalWoorden * 0.15); // 15% van totaal
            
            // Bepaal welke categorie aan de beurt is
            if (this.categorie3Count < maxCategorie3 &&
            this.gewichtTeller % 5 === 0) {
                this.categorie3Count++;
                this.gewichtTeller++;
                return categorie3;
            } else if (this.categorie2Count < maxCategorie2 &&
            this.gewichtTeller % 3 === 1) {
                this.categorie2Count++;
                this.gewichtTeller++;
                return categorie2;
            } else if (this.categorie1Count < maxCategorie1) {
                this.categorie1Count++;
                this.gewichtTeller++;
                return categorie1;
            } else {
                // Als alle categorieën zijn opgebruikt, standaard naar categorie1
                return categorie1;
            }
        }
        \end{minted}
        \caption{De hulpmethode \textit{kenGewichtToe} verdeelt de woorden in drie categorieën met verschillende gewichten (15, 28 en 60) volgens een vastgelegde verhouding van 50\%, 35\% en 15\% van het totale aantal woorden. De toekenning gebeurt volgens een rotatiepatroon.}
        \label{code:kenGewichtToe}
    \end{listing}

\section{Conclusiefase}
De implementatie van de woordwolk-library WordCloud2.js voldoet aan alle requirements, op één na: het bijhouden en weergeven van de geselecteerde properties is nog niet uitgewerkt. Desondanks heeft deze technologie aangetoond een geschikte keuze te zijn voor het visualiseren van properties op een interactieve, dynamische en prioriteitsgestuurde manier. Ze vormt een significante verbetering ten opzichte van de huidige gebruikersinterface en biedt een verbeterde navigeerbaarheid en bruikbaarheid. Dit betekent echter niet dat dit de enige mogelijke optie is. Een nieuw prototype zou ontwikkeld kunnen worden met behulp van een andere eerder opgelijste library.